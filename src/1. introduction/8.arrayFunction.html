<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // forEach : 배열의 원소들로 일괄적인 작업을 할 때 사용.
    const superheroes = ['아이언맨', '캡틴', '토르', '닥터스트레인지'];
    
    console.log('1. forEach 변수에 함수 넣기');
    function print(hero) {
      console.log(hero);
    }
    superheroes.forEach(print);
    
    console.log('2. forEach 변수에서 바로 함수 선언');
    superheroes.forEach(function(hero) {
      console.log(hero);
    })
    console.log('3. forEach 변수에서 화살표 함수 사용');
    superheroes.forEach(hero => {
      console.log(hero);
    })

    // map : 배열의 원소를 변환
    // 새로운 배열을 생성할 필요 없음.
    // 함수를 통해 변환된 결과값이 다시 배열로 생성된다.
    const array = [1,2,3,4,5,6,7,8,9];
    
    console.log('1. map파라미터에 함수 넣기');
    const square = n => n * n; // 화살표 함수 만들기
    const squared = array.map(square); // 화살표 함수넣기
    console.log(squared);

    console.log('2. map파라미터에 함수 선언하기');
    const squared2 = array.map(n => n * n); // map에 화살표 함수 바로 선언.
    console.log(squared2);

    console.log('3. 응용');
    const items = [
      {
        id: 1,
        text: 'hello'
      },
      {
        id: 2,
        text: 'bye'
      }
    ]
    const texts = items.map(item => item.text);
    console.log(texts);

    /* indexOf, index,  */
    // indexOf : 특정 원소의 인덱스를 찾음
    // findIndex : 특정 조건에 맞는 원소의 인덱스를 찾음
    // find : 특정 조건에 맞는 원소를 찾음.
    // *find, findIndex는 처음으로 찾은 것을 가져옴
    const todos = [
      {
        id: 1,
        text: '함수 배우기',
        done: true
      },
      {
        id: 2,
        text: '객체와 배열 배우기',
        done: true,
      },
      {
        id: 4,
        text: '배열 내장함수 배우기',
        done: false,
      }
    ];
    console.log('indexOf');
    const index = todos.indexOf(todos[1]);
    console.log(index);
    
    console.log('findIndex');
    const index2 = todos.findIndex(todo => todo.id === 2);
    console.log(index2);
    
    console.log('find');
    const todo = todos.find(todo => todo.done ===false);
    console.log(todo);

    /* filter */
    // 조건에 맞는 원소의 배열이 반환된다.
    console.log('filter');
    const taskNotDone = todos.filter(todo => todo.done === false);
    console.log(taskNotDone);

    /* splice, slice */
    
    // splice
    // 해당 인덱스부터 해당하는 개수의 원소를 삭제
    // 원본 배열에 영향
    console.log('splice');
    let numbers = [10, 20, 30, 40, 50];
    const spliced = numbers.splice(2, 2); 
    console.log(spliced); //잘라낸 배열을 반환
    console.log(numbers); // 잘라내고 남은 배열.

    // slice
    // 시작 인덱스부터 끝 인덱스 앞까지의 원소를 잘라냄
    // 원 배열에 영향주지 않음.
    console.log('slice');
    numbers = [10, 20, 30, 40, 50];
    const sliced = numbers.slice(2, 3);
    console.log(sliced); // 2번부터 3번 앞까지 = 2번만.
    console.log(numbers); // 원본 영향 X

    /* shift, unshift*/
    numbers = [10, 20, 30, 40, 50];
    
    // shift
    // 맨 앞의 원소를 꺼냄. 배열에 영향
    // 다 꺼내면 계속 비어있음.
    console.log('shift');
    const shifted = numbers.shift(); // 꺼낸 값을 반환
    console.log('shifted', shifted);
    console.log('numbers', numbers);

    // unshift
    // 맨 앞에 원소를 넣음. 배열에 영향
    console.log('unshift');
    const unshifted = numbers.unshift(10); // 전체 원소 개수를 반환.
    console.log('unshifted', unshifted);
    console.log('numbers', numbers);
    
    /* pop, push */
    numbers = [10, 20, 30, 40, 50];

    // pop
    // 맨 뒤의 원소를 꺼냄. 배열에 영향.
    // 다 꺼내면 계속 비어있음.
    console.log('pop');
    const poped = numbers.pop(); // 꺼낸 값을 반환
    console.log('poped', poped);
    console.log('numbers', numbers);

    // push
    // 맨 뒤에 원소를 넣음. 배열에 영향.
    console.log('push');
    const pushed = numbers.push(50); // 전체 원소 개수를 반환.
    console.log('pushed', pushed);
    console.log('numbers', numbers);
    
    /* concat */
    // 두 배열을 합치는 것
    // 기존 배열 영향X
    console.log('concat');
    const arr1 = [1, 2, 3];
    const arr2 = [4, 5, 6];
    const concated = arr1.concat(arr2);
    console.log(concated);  

    /* join */
    // 배열을 문자열로 반환
    // 구분자를 넣어줄 수 있음.
    const array2 = [1, 2, 3, 4, 5];
    console.log(array2.join());
    console.log(array2.join(' '));
    console.log(array2.join(', '));

    /* reduce */
    // 배열 연산을 간단하게 해주는 것.
    // accumulator : 초기값, 연산된 결과값
    // current : 현재 원소
    // index : current의 인덱스.
    console.log('reduce');
    numbers = [1, 2, 3, 4, 5];
    
    // 합계 구하기
    const sum = numbers.reduce((accumulator, current) => accumulator + current, 0);
    console.log('sum', sum);

    // 평균 구하기
    const avg = numbers.reduce((accumulator, current, index, array) => {
      if(index === array.length - 1) {
        return (accumulator + current) / array.length;
      }
      return accumulator + current;
    });
    console.log('avg', avg);

    // 객체 연산
    const alphabets = ['a', 'a', 'a', 'b', 'b', 'c', 'd'];
    const counts = alphabets.reduce((acc, current) => {
      if(acc[current]) { // 객체[키] = 객체.키 와 동일히다.
        acc[current] += 1;
      } else {
        acc[current] = 1;
      }
      return acc;
    }, {});
    console.log(counts);
  </script>
</body>
</html>